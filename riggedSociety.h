/* 

	riggedSociety.h: 

		This file contains the implementation of a rigged society and functions to make it work... if it can. 

 */ 

// Imports: 
#include <iostream> 
#include <fstream>
#include <string>
#include <sstream>
#include <math.h>
#include <cstdlib> 
#include <vector>
#include <random>
#include "riggingAgents.h"
using namespace std; 


namespace rS{

	/*

		riggedSociety name space. 

	*/ 

	class RiggedSociety{
		/* RiggedSociety class: 

			Objects from this class consist of a collection of agents, perhaps with some internal structure.
			RiggedSociety objects pose games for agents to play, handle how agents try to rig those games, share the
			benefits ripped up from games, and handle agent reproduction. 

			Variables: 
				>> n: number of games that each agent attempts to play. 
				>> N_A: maximum number of agents that the RiggedSociety can host. 
					> It might be interesting, in the future, to explore societies allowed to grow arbitrarily. 
				>> N_alive: number of agents living the in the RiggedSociety (<= N_A). 
				>> winningStrategies: bit array indicating which is the winning strategy for each of the games. 
				>> riggingAgents: array with the agents of the RiggedSociety. 
				>> c_R: cost of attempting to rig a game. 
				>> b: benefit to be shared among all winners of a game. 
				>> c_C: cost of replicating. 

		*/ 
		public: 
			// Variables: 
			// 	ACHTUNG!! I have made class variables public because I cannot understand how inheritance works in c++ properly... 
			int n, N_A, N_alive, *winningStrategies; 
			vector<rA::RiggingAgent> riggingAgents; 
			double c_R, b, c_C; 

			// Init functions: 
			RiggedSociety(), RiggedSociety(int, int, double, double, double, double, double, int); 
			RiggedSociety(int, int, int, double, double, double, double, double, int); 
			RiggedSociety(int, int, double, double, double, vector<rA::RiggingAgent>); 
			void initWinningStrategies(); 

			// Set and generate functions: 
			void setN(int), setN_A(int), setC_R(double), setB(double), setC_C(double); 
			void generateRiggingAgents(double, double, int), setRiggingAgents(vector<rA::RiggingAgent>); 

			// Get functions: 
			int getN(), getN_A(), getN_alive(), getWinningStrategy(int), *getWinningStrategies(); 
			rA::RiggingAgent getRiggingAgent(int); 
			vector<rA::RiggingAgent> getRiggingAgents(); 
			double getC_R(), getB(), getC_C(); 

			// Functional functions: 
			void updateN_alive(); 
			void rigGames(int, double), playGames(int), killDeadAgents(int), reproduceAgents(int), doFullStep(int, int, int, int, double); 

			// Functions to report on experiments: 
			double *getAccruedB(); 
			double *computeMajorityActions(), *computeFractionRiggedActions(); 
			double *computeMajorityRiggedActions(), computeMajorityUniggedActions; 

	}; 


	///////////////////////////////
	// 
	//  RiggedSociety functions: 

		///////////////////////////////
		// 
		//  Init Functions: 

		RiggedSociety::RiggedSociety(){return;}

		RiggedSociety::RiggedSociety(int n_, int N_A_, double c_R_, double b_, double c_C_, double p_C_=1., double b_0_=0., int initMode=0){
			/* init function for class RiggedSociety: 

				This function initializes objects of class RiggedSociety with a minimum of specifications. 

				Inputs: 
					>> n_: number of games in which each RiggingAgent of the RiggedSociety is engaged. 
					>> N_A: maximum number of RiggingAgents in the RiggedSociety. 
					>> c_R_: cost of attempting to rig a game. 
					>> b_: benefit per bit to be shared among all winners of a game. 
					>> c_C_: cost of attempting to copy (i..e reproducing) an agent. 
					>> p_C=1.: probability that the agent will replicate .
					>> b_0_=0.: the agent might be created with an initial benefit. 
					>> initMode=0: mode to initialize the behavior of the agent. 
						> 0: both actions and riggingActions are generated by drawing 0s and 1s from a uniform distribution. 
						> 1: only one rigging agent is initialized with no rigging actions whatsoever. 

			*/ 


			setN(n_); 
			setN_A(N_A_); 
			setC_R(c_R_); 
			setB(b_); 
			setC_C(c_C_); 
			generateRiggingAgents(p_C_, b_0_, initMode); 
			initWinningStrategies(); 

			return; 
		}

		RiggedSociety::RiggedSociety(int n_, int N_A_, double c_R_, double b_, double c_C_, vector<rA::RiggingAgent> riggingAgents_){
			/* init function for RiggedSociety: 

				This function initializes objects of class RiggedSociety with a given set of RiggingAgents. 

				Inputs: 
					>> n_: number of games in which each RiggingAgent of the RiggedSociety is engaged. 
					>> N_A: maximum number of RiggingAgents in the RiggedSociety. 
					>> c_R_: cost of attempting to rig a game. 
					>> b_: benefit per bit to be shared among all winners of a game. 
					>> c_C_: cost of attempting to copy (i..e reproducing) an agent. 
					>> riggingAgents_: array of RiggingAgents to inhabit the RiggedSociety. 

			*/ 

			setN(n_); 
			setN_A(N_A_); 
			setC_R(c_R_); 
			setB(b_); 
			setC_C(c_C_); 
			setRiggingAgents(riggingAgents_); 
			initWinningStrategies(); 

			return; 
		}

		void RiggedSociety::initWinningStrategies(){
			/* initWinningStrategies function: 

				This function initializes (to value 0) the array winningStrategies to avoid segmentation faults. 

				ACHTUNG!! 
					Actual winningStrategies must be generated at some point before running the simulations! 

			*/ 

			winningStrategies = new int[n]; 
			for (int i=0; i<n; i++){
				winningStrategies[i] = 0; 
			}

			return; 
		}


		///////////////////////////////
		// 
		//  Set and generate functions: 

		void RiggedSociety::setN(int n_){
			/* setN function: */ 

			n = n_; 

			return; 
		}

		void RiggedSociety::setN_A(int N_A_){
			/* setN_A function: */ 

			N_A = N_A_; 

			return; 
		}

		void RiggedSociety::setC_R(double c_R_){
			/* setC_R function: */ 

			c_R = c_R_; 

			return; 
		}

		void RiggedSociety::setB(double b_){
			/* setB function: */ 

			b = b_; 

			return; 
		}

		void RiggedSociety::setC_C(double c_C_){
			/* setC_C function: */ 

			c_C = c_C_; 

			return; 
		}

		void RiggedSociety::generateRiggingAgents(double p_C_, double b_0_, int initMode){
			/* generateRiggingAgents function: 

				This function generates an array of rigged agents. 

				Inputs: 
					>> p_C=1.: probability that the agent will replicate .
					>> b_=0.: the agent might be created with an initial benefit. 
					>> initMode=0: mode to initialize the behavior of the agent. 
						> 0: both actions and riggingActions are generated by drawing 0s and 1s from a uniform distribution. 
						> 1: only one rigging agent is initialized with no rigging actions whatsoever. 

			*/ 

			if (initMode==0){
				riggingAgents.clear(); 
				for (int i=0; i<N_A; i++){
					riggingAgents.push_back(rA::RiggingAgent(n, p_C_, b_0_, initMode)); 
				}
			}
			else if (initMode==1){
				riggingAgents.clear(); 
				riggingAgents.push_back(rA::RiggingAgent(n, p_C_, b_0_, initMode)); 
			}

			updateN_alive(); 

			return; 
		}

		void RiggedSociety::setRiggingAgents(vector<rA::RiggingAgent> riggingAgents_){
			/* setRiggingAgents function: */ 

			riggingAgents.clear(); 
			for (int i=0; i<N_A; i++){
				riggingAgents.push_back(riggingAgents_[i]); 
			}
			updateN_alive(); 

			return; 
		}


		///////////////////////////////
		// 
		//  Get functions: 

		int RiggedSociety::getN(){
			/* getN function: 

				Returns: 
					<< n: number of games in which each RiggingAgent of the RiggedSociety is engaged. 

			*/ 

			return n; 
		}

		int RiggedSociety::getN_A(){
			/* getN_A function: 

				Returns: 
					<< N_A: maximum number of RiggingAgents in the RiggedSociety. 
	
			*/ 

			return N_A; 
		}

		int RiggedSociety::getN_alive(){
			/* getN_alive function: 

				This function returns the number of agents alive in the RiggedSociety. Note that this number is
				different to the maximum number of agents in the society. 

			*/ 

			return N_alive; 
		}

		int RiggedSociety::getWinningStrategy(int iGame){
			/* getWinningStrategy function: 

				This function returns the winning strategy for game iGame. 

				Returns: 
					<< winningStrategies[iGame]: winning strategy for game iGame. 

			*/ 

			return winningStrategies[iGame]; 
		}

		int *RiggedSociety::getWinningStrategies(){
			/* getWinningStrategies function: 

				Returns: 
					<< winningStrategies: bit array indicating the winning strategy for each of the rigged games. 

			*/ 

			return winningStrategies; 
		}

		rA::RiggingAgent RiggedSociety::getRiggingAgent(int iAgent){
			/* getRiggingAgent function: 

				This function returns the RiggingAgent in position iAgent of RiggedSociety. This way we avoid retrieving
				the whole array every time! 

				Returns: 
					<< riggingAgents[iAgent]: RiggingAgent in position iAgent. 

			*/ 

			return riggingAgents[iAgent]; 
		}

		vector<rA::RiggingAgent> RiggedSociety::getRiggingAgents(){
			/* getRiggingAgents function: 

				Returns: 
					<< riggingAgents: array of RiggingAgents to inhabit the RiggedSociety. 

			*/ 

			return riggingAgents; 
		}

		double RiggedSociety::getC_R(){
			/* getC_R function: 

				Returns: 
					<< c_R: cost of attempting to rig a game. 

			*/ 

			return c_R; 
		}

		double RiggedSociety::getB(){
			/* getB function: 

				Returns: 
					<< b: benefit per bit to be shared among all winners of a game. 

			*/ 

			return b; 
		}

		double RiggedSociety::getC_C(){
			/* getC_C function: 

				Returns: 
					<< c_C: cost of attempting to copy (i..e reproducing) an agent. 

			*/ 

			return c_C; 
		}


		///////////////////////////////
		// 
		//  Functional functions: 

		void RiggedSociety::updateN_alive(){
			/* updateN_alive function: 

				This function updates N_alive to the current number of living agents. 

			*/ 

			N_alive = riggingAgents.size(); 

			return; 
		}

		void RiggedSociety::rigGames(int rigMode=0, double rigParam=1.){
			/* rigGames function: 

				This function computes the winning strategy for each game based on the rigging actions of each of the
				agents. It also subtracts from each agent's accrued benefit the corresponding cost from trying to rig
				the games. 

				The rigging is implemented in one of several ways depending on the value of the variable rigMode. 

				Inputs: 
					>> rigMode=0: Variable indicating the way in which games are rigged. 
						> 0: Simple majority with uniform random in case of draw. 
						> 1: Each agent's vote is proportional to wealth. 
					>> rigParam=1: A parameter passed to assist some of the rigging modes. 

			*/ 

			// Useful variables: 
			int nToRig, iToRig; 

			// One person one vote kind of rigging: 
			if (rigMode==0){

				// Reset winningStrategies: 
				for (int i=0; i<n; i++){
					winningStrategies[i] = 0; 
				}

				// Accumulate rigging attempts in either direction. 
				// At the same time, subtract cost of attempting to rig: 
				for (int i=0; i<N_alive; i++){
					nToRig = riggingAgents[i].getNRiggingActions(); 
					// Attempt to rig: 
					for (int j=0; j<nToRig; j++){
						iToRig = riggingAgents[i].getRiggingAction(j); 
						if (riggingAgents[i].getAction(iToRig)){
							winningStrategies[iToRig]++; 
						}
						else{
							winningStrategies[iToRig]--; 	
						}
					}
					// Subtract cost of rigging: 
					riggingAgents[i].addToB(-nToRig*c_R); 
					riggingAgents[i].addToW(-nToRig*c_R); 
				}

				// Determine direction of each game: 
				for (int i=0; i<n; i++){
					// If +, then 1 and last part of OR is not evaluated. 
					// If - or 0, then last part of OR is evaluated. Then: 
					// 	If 0 and rand()%1 generates a 1, then 1. 
					if (winningStrategies[i]>0 or (not(winningStrategies[i]) and rand()%2)){
						winningStrategies[i] = 1; 
					}
					// Otherwise (i.e. - or o and rand()%2 generates a 0): 
					else{
						winningStrategies[i] = 0; 
					}
				}
			}

			// Vote proportional to accrued b -- i.e. all earnings minus all paynments: 
			if (rigMode==1){
				// Dummy array of fouble variables to store the wealth-weighted vote: 
				double *winningStrategies_; 
				winningStrategies_ = new double[n]; 
				// Reset dummy values: 
				for (int i=0; i<n; i++){
					winningStrategies_[i] = 0.; 
				}

				// Accumulate rigging attempts in either direction. 
				// At the same time, subtract cost of attempting to rig: 
				for (int i=0; i<N_alive; i++){
					nToRig = riggingAgents[i].getNRiggingActions(); 
					// Subtract cost of rigging: 
					// Attempt to rig: 
					for (int j=0; j<nToRig; j++){
						iToRig = riggingAgents[i].getRiggingAction(j); 
						if (riggingAgents[i].getAction(iToRig)){
							winningStrategies_[iToRig] += pow(riggingAgents[i].getB(), rigParam); 
						}
						else{
							winningStrategies_[iToRig] -= pow(riggingAgents[i].getB(), rigParam); 
						}
					}
					// ACH! It is important to subtract the cost afterwards so that games are weighted with previous wealth! 
					riggingAgents[i].addToB(-nToRig*c_R); 
					riggingAgents[i].addToW(-nToRig*c_R); 
				}

				// Determine direction of each game: 
				for (int i=0; i<n; i++){
					// If +, then 1 and last part of OR is not evaluated. 
					// If - or 0, then last part of OR is evaluated. Then: 
					// 	If 0 and rand()%1 generates a 1, then 1. 
					if (winningStrategies_[i]>0 or (winningStrategies_[i]==0. and rand()%2)){
						winningStrategies[i] = 1; 
					}
					// Otherwise (i.e. - or o and rand()%2 generates a 0): 
					else{
						winningStrategies[i] = 0; 
					}
				}			
			}

			// Vote proportional to accrued W -- i.e. all earnings minus all losses except those invested in descent: 
			if (rigMode==2){
				// Dummy array of fouble variables to store the wealth-weighted vote: 
				double *winningStrategies_; 
				winningStrategies_ = new double[n]; 
				// Reset dummy values: 
				for (int i=0; i<n; i++){
					winningStrategies_[i] = 0.; 
				}

				// Accumulate rigging attempts in either direction. 
				// At the same time, subtract cost of attempting to rig: 
				for (int i=0; i<N_alive; i++){
					nToRig = riggingAgents[i].getNRiggingActions(); 
					// Subtract cost of rigging: 
					// Attempt to rig: 
					for (int j=0; j<nToRig; j++){
						iToRig = riggingAgents[i].getRiggingAction(j); 
						if (riggingAgents[i].getAction(iToRig)){
							winningStrategies_[iToRig] += pow(riggingAgents[i].getW(), rigParam); 
						}
						else{
							winningStrategies_[iToRig] -= pow(riggingAgents[i].getW(), rigParam); 
						}
					}
					// ACH! It is important to subtract the cost afterwards so that games are weighted with previous wealth! 
					riggingAgents[i].addToB(-nToRig*c_R); 
					riggingAgents[i].addToW(-nToRig*c_R); 
				}

				// Determine direction of each game: 
				for (int i=0; i<n; i++){
					// If +, then 1 and last part of OR is not evaluated. 
					// If - or 0, then last part of OR is evaluated. Then: 
					// 	If 0 and rand()%1 generates a 1, then 1. 
					if (winningStrategies_[i]>0 or (winningStrategies_[i]==0. and rand()%2)){
						winningStrategies[i] = 1; 
					}
					// Otherwise (i.e. - or o and rand()%2 generates a 0): 
					else{
						winningStrategies[i] = 0; 
					}
				}			
			}
			return; 
		}


		void RiggedSociety::playGames(int playMode=0){
			/* playGames function: 

				This function handles the RiggingAgents playing the rigged games as well as updating their benefit. 

				The games shall be played in different modes as indicated by playMode -- only the standard one at the
				moment.

				Inputs: 
					>> playMode=0: way in which games are played. No options thought of at the moment. 

			*/ 

			// To score number of correct guesses: 
			vector<int> winnerAgents; 
			int n_W = 0; 
			for (int iGame=0; iGame<n; iGame++){
				winnerAgents.clear(); 
				for (int iAgent=0; iAgent<N_alive; iAgent++){
					if (riggingAgents[iAgent].getAction(iGame)==winningStrategies[iGame]){
						winnerAgents.push_back(iAgent); 
					}
				}
				n_W = winnerAgents.size(); 
				for (int iWinner=0; iWinner<n_W; iWinner++){
					riggingAgents[winnerAgents[iWinner]].addToB(b/n_W); 
					riggingAgents[winnerAgents[iWinner]].addToW(b/n_W); 
				}
			}

			return; 
		}

		void RiggedSociety::killDeadAgents(int killMode=0){
			/* killDeadAgents function: 

				This function checks what agents are dead (i.e. have an accrued benefit lower than 0) and proceed to
				remove them from the pool. 
				Inputs: 
					>> killMode=0: In case some options need to be passed in the future. 

			*/ 

			// Find out dead RiggingAgents: 
			vector<int> deadAgents; 
			deadAgents.clear(); 
			for (int iAgent=0; iAgent<N_alive; iAgent++){
				riggingAgents[iAgent].tickAge(); 
				if (riggingAgents[iAgent].getB()<0){
					deadAgents.push_back(iAgent); 
				}
			}

			// Remove dead RiggingAgents from the populations: 
			int nDead = deadAgents.size(); 
			vector<rA::RiggingAgent>::iterator riggingAgentsBegin = riggingAgents.begin(); 
			for (int iDead=0; iDead<nDead; iDead++){
				riggingAgents.erase(riggingAgentsBegin+deadAgents.back()); 
				deadAgents.pop_back(); 
			}
			// Update number of living agents: 
			updateN_alive(); 

			return; 
		}

		void RiggedSociety::reproduceAgents(int reproduceMode=0){
			/* reproduceAgents function: 

				This function handles the reproduction of those agents who can afford it. It checks whether agents have
				an accrued benefit above a threshold, then proceeds to produce copies of them with the corresponding
				likelihood.

				Inputs: 
					>> reproduceMode=0: in case future versions need options. 

			*/ 

			// Buffer to store new agents resulting from replication: 
			vector<rA::RiggingAgent> bufferRiggingAgents; 
			bufferRiggingAgents.clear(); 

			// Loop over agents to check which ones get reproduced: 
			for (int iAgent=0; iAgent<N_alive; iAgent++){
				if (riggingAgents[iAgent].getB()>c_C and (float(rand())/RAND_MAX) < riggingAgents[iAgent].getP_C()){
					bufferRiggingAgents.push_back(rA::RiggingAgent(riggingAgents[iAgent])); 
					riggingAgents[iAgent].addToB(-c_C); 
				}
			}

			// Loop over new agents to mutate them; set age, accrued benefit, and wealth to 0; and allocate them to the RiggedSociety: 
			int iToAllocate;
			for (int i=0; i<bufferRiggingAgents.size(); i++){
				bufferRiggingAgents[i].setAge(0); 			
				bufferRiggingAgents[i].setB(0.); 
				bufferRiggingAgents[i].setW(0.); 
				bufferRiggingAgents[i].mutate(); 
				iToAllocate = rand()%N_A; 
				if (iToAllocate<N_alive){
					riggingAgents[iToAllocate] = bufferRiggingAgents[i]; 
				}
				else{
					riggingAgents.push_back(bufferRiggingAgents[i]); 
					updateN_alive(); 
				}
			}

			return; 
		}

		void RiggedSociety::doFullStep(int rigMode=0, int playMode=0, int killMode=0, int reproduceMode=0, double rigParam=0.){
			/* doFullStep fucntion: 

				This function calls all relevat functions to implement a time step of the RiggedSociety evolution. 

				Inputs: 
					>> rigMode=0, playMode=0, killMode=0, reproduceMode=0: in case options need to be passed in the future. 
					>> rigParam: A parameter to assist the implementation of some of the rigging modes. 

			*/ 

			rigGames(rigMode, rigParam); 
			playGames(playMode); 
			killDeadAgents(killMode); 
			reproduceAgents(reproduceMode); 

			return; 
		}

		///////////////////////////////
		// 
		//  Functions to report on experiments: 

		double *RiggedSociety::getAccruedB(){
			/* getAccruedB function: 

				This fucntion returns the accrued benefits across the whole RiggedSociety. 

				Returns: 
					<< accruedB: benefits accrued by all RiggingAgents in the whole RiggedSociety. 

			*/ 

			double *accruedB; 
			accruedB = new double[N_alive]; 
			for (int iAgent=0; iAgent<N_alive; iAgent++){
				accruedB[iAgent] = riggingAgents[iAgent].getB(); 
			}

			return accruedB; 
		}

		double *RiggedSociety::computeMajorityActions(){
			/* computeMajorityActions function: 

				This function computes the average action across the RiggedSociety for each game. 

				Returns: 
					<< majorityAction: number between 0 and 1 indicating the fraction of RiggingAgents that vouche for 1 in each game. 

			*/ 

			double *majorityAction; 
			majorityAction = new double[n]; 
			for (int iGame=0; iGame<n; iGame++){
				majorityAction[iGame] = 0.; 
				for (int iAgent=0; iAgent<N_alive; iAgent++){
					majorityAction[iGame] += float(riggingAgents[iAgent].getAction(iGame))/N_alive; 
				}
			}

			return majorityAction; 
		}

		double *RiggedSociety::computeFractionRiggedActions(){
			/* computeFractionRiggedActions function: 

				This fucntion computes the fraction of RiggingAgents that are attempting to rig each of the games. 

				Returns: 
					<< fractionRiggedActions: fraction of agents attempting to rig each of the games. 

			*/ 

			double *fractionRiggedActions; 
			fractionRiggedActions = new double[n]; 
			for (int iGame=0; iGame<n; iGame++){
				fractionRiggedActions[iGame] = 0; 
			}
			for (int iAgent=0; iAgent<N_alive; iAgent++){
				for (int iGame=0; iGame<riggingAgents[iAgent].getNRiggingActions(); iGame++){
					fractionRiggedActions[riggingAgents[iAgent].getRiggingAction(iGame)] += 1./N_alive; 
				}
			}

			return fractionRiggedActions; 
		}


	// End of RiggedSociety class! 
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







}	// EOF!! 




